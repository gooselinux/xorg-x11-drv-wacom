From 7ad970862b6355114a17011970ca1b52f2cdd405 Mon Sep 17 00:00:00 2001
From: Peter Hutterer <peter.hutterer@who-t.net>
Date: Wed, 27 Oct 2010 10:56:04 +1000
Subject: [PATCH 09/11] xsetwacom: print special button maps.

If a device has something more complex than a simple button mapping for a
given button, print it.
Note that this doesn't simplify the mappings, so
    xsetwacom set <device> Button1 "button 1"
will print as
    ... "button +1 -1"
instead.

Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>
(cherry picked from commit f9f2a531e81c97b0d56175844de02017540c37fc)
---
 tools/xsetwacom.c |   96 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 96 insertions(+), 0 deletions(-)

diff --git a/tools/xsetwacom.c b/tools/xsetwacom.c
index 9858a95..20a66f1 100644
--- a/tools/xsetwacom.c
+++ b/tools/xsetwacom.c
@@ -1931,6 +1931,98 @@ static void get_presscurve(Display *dpy, XDevice *dev, param_t *param, int argc,
 	print_value(param, "%s", buff);
 }
 
+static int get_special_button_map(Display *dpy, XDevice *dev,
+				  param_t *param, int btn_no)
+{
+	Atom btnact_prop, action_prop;
+	unsigned long *btnact_data;
+	Atom type;
+	int format;
+	unsigned long btnact_nitems, bytes_after;
+	int i;
+	char buff[1024] = {0};
+
+	btnact_prop = XInternAtom(dpy, "Wacom Button Actions", True);
+
+	if (!btnact_prop)
+		return 0;
+
+	XGetDeviceProperty(dpy, dev, btnact_prop, 0, 100, False,
+			   AnyPropertyType, &type, &format, &btnact_nitems,
+			   &bytes_after, (unsigned char**)&btnact_data);
+
+	/* button numbers start at 1, property is zero-indexed */
+	if (btn_no >= btnact_nitems)
+		return 0;
+
+	/* FIXME: doesn't cover wheels/strips at the moment, they can be 8
+	 * bits (plain buttons) or 32 bits (complex actions) */
+
+	action_prop = btnact_data[btn_no - 1];
+	if (!action_prop)
+		return 0;
+
+	XFree(btnact_data);
+
+	XGetDeviceProperty(dpy, dev, action_prop, 0, 100, False,
+			   AnyPropertyType, &type, &format, &btnact_nitems,
+			   &bytes_after, (unsigned char**)&btnact_data);
+
+	if (format != 32 && type != XA_ATOM)
+		return 0;
+
+	for (i = 0; i < btnact_nitems; i++)
+	{
+		static int last_type, last_press;
+		unsigned long action = btnact_data[i];
+		int current_type;
+		int detail;
+		int is_press = -1;
+		char str[10] = {0};
+
+		current_type = action & AC_TYPE;
+		detail = action & AC_CODE;
+
+
+		switch (current_type)
+		{
+			case AC_KEY:
+				if (last_type != current_type)
+					strcat(buff, "key ");
+				is_press = !!(action & AC_KEYBTNPRESS);
+				break;
+			case AC_BUTTON:
+				if (last_type != current_type)
+					strcat(buff, "button ");
+				is_press = !!(action & AC_KEYBTNPRESS);
+				break;
+			case AC_MODETOGGLE:
+				strcat(buff, "modetoggle ");
+				break;
+			case AC_DISPLAYTOGGLE:
+				strcat(buff, "displaytoggle ");
+				break;
+			default:
+				TRACE("unknown type %d\n", current_type);
+				continue;
+		}
+
+		sprintf(str, "%s%d ",
+			(is_press == -1) ? "" : ((is_press) ?  "+" : "-"), detail);
+		strcat(buff, str);
+		last_type = current_type;
+		last_press = is_press;
+	}
+
+	TRACE("%s\n", buff);
+
+	XFree(btnact_data);
+
+	print_value(param, "%s", buff);
+
+	return 1;
+}
+
 static void get_button(Display *dpy, XDevice *dev, param_t *param, int argc,
 			char **argv)
 {
@@ -1944,6 +2036,10 @@ static void get_button(Display *dpy, XDevice *dev, param_t *param, int argc,
 
 	TRACE("Getting button map curve for device %ld.\n", dev->device_id);
 
+	/* if there's a special map, print it and return */
+	if (get_special_button_map(dpy, dev, param, btn_no))
+		return;
+
 	nmap = XGetDeviceButtonMapping(dpy, dev, map, nmap);
 
 	if (btn_no > nmap)
-- 
1.7.1

